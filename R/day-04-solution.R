###
# Advent of Code 2023: Day 4 Solution
# Zane Billings
# 2023-12-04
###

# SETUP ----

# Load common functions
source(here::here("R", "funcs.R"))

# Read in the input file
input <-
	readr::read_lines(here::here("data", "day-04-input.txt"))

# PART 1 SOLUTION ----
# This problem is actually basically a data cleaning puzzle :) so it shouldn't
# be too bad for me. So the first thing we need to do is data cleaning. Once
# the data are in a nice format, we can count the number of matches to get the
# number of points for each category.

card_data <-
	tibble::tibble(raw = input) |>
	tidyr::separate_wider_delim(
		cols = raw,
		delim = ": ",
		names = c("card", "numbers")
	) |>
	tidyr::separate_wider_delim(
		cols = numbers,
		delim = " | ",
		names = c("winning", "have")
	) |>
	dplyr::mutate(
		card = stringr::str_extract(card, "\\d+") |> as.integer(),
		winning = winning |>
			stringr::str_squish() |>
			stringr::str_split(pattern = "\\s") |>
			purrr::map(as.numeric),
		have = have |>
			stringr::str_squish() |>
			stringr::str_split(pattern = "\\s") |>
			purrr::map(as.numeric)
	) |>
	tidyr::unnest(have) |>
	dplyr::rowwise() |>
	dplyr::mutate(match = have %in% winning) |>
	dplyr::ungroup()

score_cards <- function(card_data) {
	out <-
		card_data |>
		dplyr::group_by(card) |>
		dplyr::summarise(
			num_matches = sum(match),
			points = ifelse(num_matches == 0, 0, 2 ^ (num_matches - 1))
		)
	return(out)
}

card_points <- score_cards(card_data)

output_p1 <- sum(card_points$points)
print_answer(1, output_p1)

# PART 2 SOLUTION ----
# Nest the original card data -- this contains one column with an ID and one
# with the data on matches for each original (non-copy) card.
cards_nested <- card_data |>
	tidyr::nest(dat = -card)

# Now we need a function to generate the copies. 

# This helper function constructs the sequence of card copies that we win from
# a given card.
get_indices_for_slicing <- function(card, num_matches) {
	if(num_matches == 0) {
		return(integer())
	} else {
		return(seq(card + 1, card + num_matches))
	}
}

# This function takes the scored data
# generated by score_cards() and returns a data frame of all of the copies we
# win from that scored data frame.
generate_copies <- function(scored_data) {
	# First generate a vector of integers of the card copies that we won
	copies_we_won <-
		purrr::map2(
			scored_data$card, scored_data$num_matches,
			\(x, y) get_indices_for_slicing(x, y)
		) |>
		do.call(what = c)
	
	# Now we return that in a tibble form.
	copies_data <-
		tibble::tibble(card = copies_we_won)
	
	return(copies_data)
}

# Now we need to score the copies and generate copies, until we
# don't get anymore.
get_all_copies <- function(scores) {
	# Generate starting values
	num_cards <- nrow(scores)
	paste0("The starting number of cards is: ", num_cards) |>
		crayon::green() |>
		rlang::inform()
	
	# Make the first set of copies
	# Note that we already computed the score for each card so we don't need
	# to score them again
	copies <- generate_copies(scores)
	copy_scores <- dplyr::left_join(copies, scores, by = "card")
	num_cards <- num_cards + nrow(copy_scores)
	n_copies <- 1
	paste0("Number of cards after 1 copy: ", num_cards) |>
		crayon::green() |>
		rlang::inform()
	
	cnd <- TRUE
	while(cnd) {
		# Do the copying and scoring and stuff
		copies <- generate_copies(copy_scores)
		n_copies <- n_copies + 1
		copy_scores <- dplyr::left_join(copies, scores, by = "card")
		num_cards <- num_cards + nrow(copy_scores)
		
		# Print message
		paste0("Number of cards after ", n_copies, " copies: ", num_cards) |>
			crayon::green() |>
			rlang::inform()
		
		# Update condition
		cnd <- (nrow(copies) != 0)
	}
	
	return(num_cards)
}

card_points |>
	dplyr::select(-points) ->
	scores

output_p2 <-
	card_points |>
	dplyr::select(-points) |>
	get_all_copies()
print_answer(2, output_p2)

# END OF FILE ----
